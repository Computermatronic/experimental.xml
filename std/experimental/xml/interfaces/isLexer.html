<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8"/>
		<title>Enum member isLexer</title>
		<link rel="stylesheet" type="text/css" href="../../../../styles/ddox.css"/>
		<link rel="stylesheet" href="../../../../prettify/prettify.css" type="text/css"/>
		<script type="text/javascript" src="../../../../scripts/jquery.js">/**/</script>
		<script type="text/javascript" src="../../../../scripts/ddox.js">/**/</script>
	</head>
	<body onload="setupDdox();">
		<nav id="main-nav">
						<ul class="tree-view">
							<li class="tree-view">
								<a href="#" class="package">std</a>
						<ul class="tree-view">
							<li class="tree-view">
								<a href="#" class="package">experimental</a>
						<ul class="tree-view">
							<li class="tree-view">
								<a href="#" class="package">xml</a>
						<ul class="tree-view">
							<li>
								<a href="../../../../std/experimental/xml.html" class=" module">Package members</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/cursor.html" class=" module">cursor</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/dom.html" class=" module">dom</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/domimpl.html" class=" module">domimpl</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/domparser.html" class=" module">domparser</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/dtd.html" class=" module">dtd</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/faststrings.html" class=" module">faststrings</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/interfaces.html" class="selected module">interfaces</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/legacy.html" class=" module">legacy</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/lexers.html" class=" module">lexers</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/parser.html" class=" module">parser</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/sax.html" class=" module">sax</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/validation.html" class=" module">validation</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/writer.html" class=" module">writer</a>
							</li>
						</ul>
							</li>
						</ul>
							</li>
						</ul>
							</li>
						</ul>
				<noscript>
					<p style="color: red">The search functionality needs JavaScript enabled</p>
				</noscript>
				<div id="symbolSearchPane" style="display: none">
					<p>
						<input id="symbolSearch" type="text" placeholder="Search for symbols" onchange="performSymbolSearch(24);" onkeypress="this.onchange();" onpaste="this.onchange();" oninput="this.onchange();"/>
					</p>
	<ul id="symbolSearchResults" style="display: none"></ul>
	<script type="application/javascript" src="../../../../symbols.js"></script>
	<script type="application/javascript">
var symbolSearchRootDir = "../../../../";
$('#symbolSearchPane').show();
	</script>
				</div>
		</nav>
		<div id="main-contents">
			<h1>Enum member isLexer</h1>
			<section>
				<p>Checks whether its argument fulfills all requirements to be used as an XML lexer.
</p>
<section><p>An XML lexer is the first component in the parsing chain. It masks from the parser
   the shape of the input and the type of the characters in it. The slices returned by
   the lexer are ephemeral: every reference to them may or may not be invalidated when a
   new slice is requested by the parser. It is thus responsibility of the user to copy the
   output if necessary.
</p>
</section>

					<section>
						<h3>Declaration</h3>
						<div class="prototype">
							<code class="lang-d">
<span class="kwd">enum</span> <span class="pln">isLexer</span><span class="pun">(</span><span class="pln">L</span><span class="pun">)</span> <span class="pun">=</span> <span class="kwd">is</span><span class="pun">(</span><span class="kwd">typeof</span><span class="pun">((</span><span class="kwd">inout </span><span class="typ">int </span><span class="pun">= </span><span class="lit">0</span><span class="pun">)
{
</span><span class="kwd">alias </span><span class="pln">C </span><span class="pun">= </span><span class="pln">L<wbr/></span><span class="pun">.</span><span class="typ">CharacterType</span><span class="pun">;
</span><span class="pln">L lexer</span><span class="pun">;
</span><span class="typ">char </span><span class="pln">c</span><span class="pun">;
</span><span class="typ">bool </span><span class="pln">b</span><span class="pun">;
</span><span class="typ">string </span><span class="pln">s</span><span class="pun">;
</span><span class="pln">C</span><span class="pun">[] </span><span class="pln">cs</span><span class="pun">;
</span><span class="pln">b </span><span class="pun">= </span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">empty</span><span class="pun">;
</span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">start</span><span class="pun">();
</span><span class="pln">cs </span><span class="pun">= </span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">get</span><span class="pun">();
</span><span class="pln">b </span><span class="pun">= </span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">testAndAdvance</span><span class="pun">(</span><span class="pln">c</span><span class="pun">);
</span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">advanceUntil</span><span class="pun">(</span><span class="pln">c</span><span class="pun">, </span><span class="pln">b</span><span class="pun">);
</span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">advanceUntilAny</span><span class="pun">(</span><span class="pln">s</span><span class="pun">, </span><span class="pln">b</span><span class="pun">);
</span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">dropWhile</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);
}
))</span><span class="pun">;</span>
							</code>
						</div>
					</section>
<section><h3>Parameters</h3>
<table><col class="caption"><tr><th>Name</th><th>Description</th></tr>
<tr><td id="L">L</td><td> the type to be tested</td></tr>
</table>
</section>
<section><h3>Returns</h3>
<p><code class="lang-d"><span class="kwd">true</span></code> if L satisfies the XML lexer specification here stated; <code class="lang-d"><span class="kwd">false</span></code> otherwise
</p>
</section>
<section><h3>Specification</h3>
<p>A lexer shall support at least these methods and aliases:
   <ul>       <li><code class="lang-d"><span class="kwd">alias </span><span class="typ">CharacterType</span></code>: the type of a single source character; most
             methods will deal with slices of this type;</li>
       <li><code class="lang-d"><span class="kwd">alias </span><span class="typ">InputType</span></code>: the type of the input which is used to feed this
             lexer;</li>
       <li><code class="lang-d"><span class="typ">void </span><span class="pln">setSource</span><span class="pun">(</span><span class="typ">InputType</span><span class="pun">)</span></code>: sets the input source for this lexer;
             the lexer may perform other initialization work and even consume
             part of the input during this operation; after (partial or complete)
             usage, a lexer may be reinitialized and used with another input
             by calling this function;</li>
       <li><code class="lang-d"><span class="typ">bool </span><span class="pln">empty</span><span class="pun">()</span></code>: returns <code class="lang-d"><span class="kwd">true</span></code> if the entire input has been consumed;
            <code class="lang-d"><span class="kwd">false</span></code> otherwise;</li>
       <li><code class="lang-d"><span class="typ">void </span><span class="pln">start</span><span class="pun">()</span></code>: instructs the lexer that a new token starts at the
             current positions; the next calls to <code class="lang-d"><span class="pln">get</span></code> will retrive the input
             from the current position; this call may invalidate any reference
             to any slice previosly returned from <code class="lang-d"><span class="pln">get</span></code></li>
       <li><code class="lang-d"><span class="typ">CharacterType</span><span class="pun">[] </span><span class="pln">get</span><span class="pun">()</span></code>: returns the contents of the input going from
             the last call to <code class="lang-d"><span class="pln">start</span></code> till the current position;</li>
       <li><code class="lang-d"><span class="typ">bool </span><span class="pln">testAndAdvance</span><span class="pun">(</span><span class="typ">CharacterType</span><span class="pun">)</span></code>: tests whether the input character
             at the current position matches the one passed as parameter; if
             it is the case, this method returns <code class="lang-d"><span class="kwd">true</span></code> and advances the input
             past the said character; otherwise, it returns <code class="lang-d"><span class="kwd">false</span></code> and no action
             is performed;</li>
       <li><code class="lang-d"><span class="typ">void </span><span class="pln">advanceUntil</span><span class="pun">(</span><span class="typ">CharacterType</span><span class="pun">, </span><span class="typ">bool</span><span class="pun">)</span></code>: advances the input until
             the given character is found; if the second parameter is true, the
             input is then advanced past the found character;</li>
       <li><code class="lang-d"><span class="typ">void </span><span class="pln">advanceUntilAny</span><span class="pun">(</span><span class="typ">CharacterType</span><span class="pun">[], </span><span class="typ">bool</span><span class="pun">)</span></code>: advances the input
             until any of the given characters is found; if the second parameter
             is true, the input is then advanced past the found character;</li>
       <li><code class="lang-d"><span class="typ">void </span><span class="pln">dropWhile</span><span class="pun">(</span><span class="typ">CharacterType</span><span class="pun">[])</span></code>: advances the input until a character
             different from the given ones is found; the characters advanced by
             this method may or may not be included in the output of a subsequent
             <code class="lang-d"><span class="pln">get</span></code>; for this reason, this method should only be called immediately
             before <code class="lang-d"><span class="pln">start</span></code>, to skip unneeded characters between two tokens.</li>
   </ul>
</p>
</section>
<section><h3>Examples</h3>
<pre class="code"><code class="lang-d"><span class="com">/* extract a word surrounded by whitespaces */
</span><span class="kwd">auto </span><span class="pln">getWord</span><span class="pun">(</span><span class="pln">L</span><span class="pun">)(</span><span class="kwd">ref </span><span class="pln">L lexer</span><span class="pun">)
    </span><span class="kwd">if </span><span class="pun">(</span><span class="pln">isLexer</span><span class="pun">!</span><span class="pln">L</span><span class="pun">)
{
    </span><span class="com">// drop leading whitespaces
    </span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">dropWhile</span><span class="pun">(</span><span class="str">" \n\r\t"</span><span class="pun">);

    </span><span class="com">// start building the word
    </span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">start</span><span class="pun">;

    </span><span class="com">// keep advancing until you find the trailing whitespaces
    </span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">advanceUntilAny</span><span class="pun">(</span><span class="str">" \n\r\t"</span><span class="pun">, </span><span class="kwd">false</span><span class="pun">);

    </span><span class="com">// return what you found
    </span><span class="kwd">return </span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">get</span><span class="pun">;
}

</span><span class="com">/* extract a key/value pair from a string like " key : value " */
</span><span class="kwd">auto </span><span class="pln">getKeyValuePair</span><span class="pun">(</span><span class="kwd">ref </span><span class="pln">L lexer</span><span class="pun">)
    </span><span class="kwd">if </span><span class="pun">(</span><span class="pln">isLexer</span><span class="pun">!</span><span class="pln">L</span><span class="pun">)
{
    </span><span class="com">// drop leading whitespaces
    </span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">dropWhile</span><span class="pun">(</span><span class="str">" \n\r\t"</span><span class="pun">);

    </span><span class="com">// here starts the key, which ends with either a whitespace or a colon
    </span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">start</span><span class="pun">;
    </span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">advanceUntilAny</span><span class="pun">(</span><span class="str">" \n\r\t:"</span><span class="pun">, </span><span class="kwd">false</span><span class="pun">);
    </span><span class="kwd">auto </span><span class="pln">key </span><span class="pun">= </span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">get</span><span class="pun">;

    </span><span class="com">// skip any spaces after the key
    </span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">dropWhile</span><span class="pun">(</span><span class="str">" \n\r\t"</span><span class="pun">);
    </span><span class="com">// now there must be a colon
    </span><span class="kwd">assert</span><span class="pun">(</span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">testAndAdvance</span><span class="pun">(</span><span class="str">':'</span><span class="pun">));
    </span><span class="com">// skip all space after the colon
    </span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">dropWhile</span><span class="pun">(</span><span class="str">" \n\r\t"</span><span class="pun">);

    </span><span class="com">// here starts the value, which ends at the first whitespace
    </span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">start</span><span class="pun">;
    </span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">advanceUntilAny</span><span class="pun">(</span><span class="str">" \n\r\t"</span><span class="pun">, </span><span class="kwd">false</span><span class="pun">);
    </span><span class="kwd">auto </span><span class="pln">value </span><span class="pun">= </span><span class="pln">lexer<wbr/></span><span class="pun">.</span><span class="pln">get</span><span class="pun">;

    </span><span class="com">// return the pair
    </span><span class="kwd">return </span><span class="pln">tuple</span><span class="pun">(</span><span class="pln">key</span><span class="pun">, </span><span class="pln">value</span><span class="pun">);
}</span></code></pre>
</section>

			</section>
			<section>
				<h2>Authors</h2>
<p>Lodovico Giaretta
</p>

			</section>
			<section>
				<h2>Copyright</h2>
<p>Copyright Lodovico Giaretta 2016 --
</p>

			</section>
			<section>
				<h2>License</h2>
<p><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
</p>

			</section>
		</div>
	</body>
</html>