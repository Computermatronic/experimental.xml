<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8"/>
		<title>Enum DocumentPosition</title>
		<link rel="stylesheet" type="text/css" href="../../../../styles/ddox.css"/>
		<link rel="stylesheet" href="../../../../prettify/prettify.css" type="text/css"/>
		<script type="text/javascript" src="../../../../scripts/jquery.js">/**/</script>
		<script type="text/javascript" src="../../../../scripts/ddox.js">/**/</script>
	</head>
	<body onload="setupDdox();">
		<nav id="main-nav">
						<ul class="tree-view">
							<li class="tree-view">
								<a href="#" class="package">std</a>
						<ul class="tree-view">
							<li class="tree-view">
								<a href="#" class="package">experimental</a>
						<ul class="tree-view">
							<li class="tree-view">
								<a href="#" class="package">xml</a>
						<ul class="tree-view">
							<li>
								<a href="../../../../std/experimental/xml.html" class=" module">Package members</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/appender.html" class=" module">appender</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/cursor.html" class=" module">cursor</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/dom.html" class="selected module">dom</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/domimpl.html" class=" module">domimpl</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/domparser.html" class=" module">domparser</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/dtd.html" class=" module">dtd</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/faststrings.html" class=" module">faststrings</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/interfaces.html" class=" module">interfaces</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/legacy.html" class=" module">legacy</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/lexers.html" class=" module">lexers</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/parser.html" class=" module">parser</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/sax.html" class=" module">sax</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/validation.html" class=" module">validation</a>
							</li>
							<li>
								<a href="../../../../std/experimental/xml/writer.html" class=" module">writer</a>
							</li>
						</ul>
							</li>
						</ul>
							</li>
						</ul>
							</li>
						</ul>
				<noscript>
					<p style="color: red">The search functionality needs JavaScript enabled</p>
				</noscript>
				<div id="symbolSearchPane" style="display: none">
					<p>
						<input id="symbolSearch" type="text" placeholder="Search for symbols" onchange="performSymbolSearch(24);" onkeypress="this.onchange();" onpaste="this.onchange();" oninput="this.onchange();"/>
					</p>
	<ul id="symbolSearchResults" style="display: none"></ul>
	<script type="application/javascript" src="../../../../symbols.js"></script>
	<script type="application/javascript">
var symbolSearchRootDir = "../../../../";
$('#symbolSearchPane').show();
	</script>
				</div>
		</nav>
		<div id="main-contents">
			<h1>Enum DocumentPosition</h1>
			<section>
				<p>A bitmask indicating the relative document position of a node with respect to another node.
</p>
<section><p>If the two nodes being compared are the same node, then no flags are set on the return.
</p>

<p>   Otherwise, the order of two nodes is determined by looking for common containers --
   containers which contain both. A node directly contains any child nodes. A node
   also directly contains any other nodes attached to it such as attributes contained
   in an element or entities and notations contained in a document type. Nodes contained
   in contained nodes are also contained, but less-directly as the number of intervening
   containers increases.
</p>

<p>   If there is no common container node, then the order is based upon order between
   the root container of each node that is in no container. In this case, the result
   is disconnected and implementation-specific. This result is stable as long as these
   outer-most containing nodes remain in memory and are not inserted into some other
   containing node. This would be the case when the nodes belong to different documents
   or fragments, and cloning the document or inserting a fragment might change the order.
</p>

<p>   If one of the nodes being compared contains the other node, then the container precedes
   the contained node, and reversely the contained node follows the container. For example,
   when comparing an element against its own attribute or child, the element node precedes
   its attribute node and its child node, which both follow it.
</p>

<p>   If neither of the previous cases apply, then there exists a most-direct container
   common to both nodes being compared. In this case, the order is determined based
   upon the two determining nodes directly contained in this most-direct common
   container that either are or contain the corresponding nodes being compared.
</p>

<p>   If these two determining nodes are both child nodes, then the natural DOM order
   of these determining nodes within the containing node is returned as the order
   of the corresponding nodes. This would be the case, for example, when comparing
   two child elements of the same element.
</p>

<p>   If one of the two determining nodes is a child node and the other is not, then
   the corresponding node of the child node follows the corresponding node of the
   non-child node. This would be the case, for example, when comparing an attribute
   of an element with a child element of the same element.
</p>

<p>   If neither of the two determining node is a child node and one determining node
   has a greater value of nodeType than the other, then the corresponding node precedes
   the other. This would be the case, for example, when comparing an entity of a document
   type against a notation of the same document type.
</p>

<p>   If neither of the two determining node is a child node and nodeType is the same
   for both determining nodes, then an implementation-dependent order between the
   determining nodes is returned. This order is stable as long as no nodes of the
   same nodeType are inserted into or removed from the direct container. This would
   be the case, for example, when comparing two attributes of the same element, and
   inserting or removing additional attributes might change the order between existing
   attributes.
</p>
</section>

					<p>The enum base type is
						<code class="prettyprint lang-d"><span class="typ">ushort</span></code>
.
					</p>
					<section>
						<h3>Enum members</h3>
						<table>
							<col class="caption"/>
							<tr>
								<th>Name</th>
								<th>Description</th>
							</tr>
						</table>
					</section>

			</section>
			<section>
				<h2>Authors</h2>
<p>Lodovico Giaretta
</p>

			</section>
			<section>
				<h2>Copyright</h2>
<p>Copyright Lodovico Giaretta 2016 --
</p>

			</section>
			<section>
				<h2>License</h2>
<p><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
</p>

			</section>
		</div>
	</body>
</html>