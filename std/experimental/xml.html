<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8"/>
		<title>Module std.experimental.xml</title>
		<link rel="stylesheet" type="text/css" href="../../styles/ddox.css"/>
		<link rel="stylesheet" href="../../prettify/prettify.css" type="text/css"/>
		<script type="text/javascript" src="../../scripts/jquery.js">/**/</script>
		<script type="text/javascript" src="../../scripts/ddox.js">/**/</script>
	</head>
	<body onload="setupDdox();">
		<nav id="main-nav">
						<ul class="tree-view">
							<li class="tree-view">
								<a href="#" class="package">std</a>
						<ul class="tree-view">
							<li class="tree-view">
								<a href="#" class="package">experimental</a>
						<ul class="tree-view">
							<li class="tree-view">
								<a href="#" class="package">xml</a>
						<ul class="tree-view">
							<li>
								<a href="../../std/experimental/xml.html" class="selected module">Package members</a>
							</li>
							<li>
								<a href="../../std/experimental/xml/appender.html" class=" module">appender</a>
							</li>
							<li>
								<a href="../../std/experimental/xml/cursor.html" class=" module">cursor</a>
							</li>
							<li>
								<a href="../../std/experimental/xml/dom.html" class=" module">dom</a>
							</li>
							<li>
								<a href="../../std/experimental/xml/domimpl.html" class=" module">domimpl</a>
							</li>
							<li>
								<a href="../../std/experimental/xml/domparser.html" class=" module">domparser</a>
							</li>
							<li>
								<a href="../../std/experimental/xml/dtd.html" class=" module">dtd</a>
							</li>
							<li>
								<a href="../../std/experimental/xml/faststrings.html" class=" module">faststrings</a>
							</li>
							<li>
								<a href="../../std/experimental/xml/interfaces.html" class=" module">interfaces</a>
							</li>
							<li>
								<a href="../../std/experimental/xml/legacy.html" class=" module">legacy</a>
							</li>
							<li>
								<a href="../../std/experimental/xml/lexers.html" class=" module">lexers</a>
							</li>
							<li>
								<a href="../../std/experimental/xml/parser.html" class=" module">parser</a>
							</li>
							<li>
								<a href="../../std/experimental/xml/sax.html" class=" module">sax</a>
							</li>
							<li>
								<a href="../../std/experimental/xml/validation.html" class=" module">validation</a>
							</li>
							<li>
								<a href="../../std/experimental/xml/writer.html" class=" module">writer</a>
							</li>
						</ul>
							</li>
						</ul>
							</li>
						</ul>
							</li>
						</ul>
				<noscript>
					<p style="color: red">The search functionality needs JavaScript enabled</p>
				</noscript>
				<div id="symbolSearchPane" style="display: none">
					<p>
						<input id="symbolSearch" type="text" placeholder="Search for symbols" onchange="performSymbolSearch(24);" onkeypress="this.onchange();" onpaste="this.onchange();" oninput="this.onchange();"/>
					</p>
	<ul id="symbolSearchResults" style="display: none"></ul>
	<script type="application/javascript" src="../../symbols.js"></script>
	<script type="application/javascript">
var symbolSearchRootDir = "../../";
$('#symbolSearchPane').show();
	</script>
				</div>
		</nav>
		<div id="main-contents">
			<h1>Module std.experimental.xml</h1>
			<p>An xml processing library.
</p>
<section><p><h2>Quick start</h2>
   The library offers a simple fluid interface to build an XML parsing chain.
   Let's see a first example: we want to change the name of an author in our book
   catalogue, using DOM.
</p>
<pre class="code"><code class="lang-d"><span class="typ">string </span><span class="pln">input </span><span class="pun">= </span><span class="str">q"{
&lt;?xml version = "1.0"?&gt;
&lt;books&gt;
    &lt;book ISBN = "078-5342635362"&gt;
        &lt;title&gt;The D Programming Language&lt;/title&gt;
        &lt;author&gt;A. Alexandrescu&lt;/author&gt;
    &lt;/book&gt;
    &lt;book ISBN = "978-1515074601"&gt;
        &lt;title&gt;Programming in D&lt;/title&gt;
        &lt;author&gt;Ali Ã‡ehreli&lt;/author&gt;
    &lt;/book&gt;
    &lt;book ISBN = "978-0201704310"&gt;
        &lt;title&gt;Modern C++ Design&lt;/title&gt;
        &lt;author&gt;A. Alexandrescu&lt;/author&gt;
    &lt;/book&gt;
&lt;/books&gt;
}"</span><span class="pun">;

</span><span class="com">// the following steps are all configurable
</span><span class="kwd">auto </span><span class="pln">domBuilder </span><span class="pun">=
     </span><span class="pln">chooseLexer</span><span class="pun">!</span><span class="pln">input  </span><span class="com">// instantiate the best lexer based on the type of input
    <wbr/></span><span class="pun">.</span><span class="pln">parser             </span><span class="com">// instantiate a parser on top of the lexer
    <wbr/></span><span class="pun">.</span><span class="pln">cursor             </span><span class="com">// instantiate a cursor on top of the parser
    <wbr/></span><span class="pun">.</span><span class="pln">domBuilder</span><span class="pun">;        </span><span class="com">// and finally the DOM builder on top of the cursor

// the source is forwarded down the parsing chain and everything is initialized
</span><span class="pln">domBuilder<wbr/></span><span class="pun">.</span><span class="pln">setSource</span><span class="pun">(</span><span class="pln">input</span><span class="pun">);

</span><span class="com">// recursively build the entire DOM tree
</span><span class="pln">domBuilder<wbr/></span><span class="pun">.</span><span class="pln">buildRecursive</span><span class="pun">;
</span><span class="kwd">auto </span><span class="pln">dom </span><span class="pun">= </span><span class="pln">domBuilder<wbr/></span><span class="pun">.</span><span class="pln">getDocument</span><span class="pun">;

</span><span class="com">// find and substitute all matching authors
</span><span class="kwd">foreach </span><span class="pun">(</span><span class="pln">author</span><span class="pun">; </span><span class="pln">dom<wbr/></span><span class="pun">.</span><span class="pln">getElementsByTagName</span><span class="pun">(</span><span class="str">"author"</span><span class="pun">))
    </span><span class="kwd">if </span><span class="pun">(</span><span class="pln">author<wbr/></span><span class="pun">.</span><span class="pln">textContent </span><span class="pun">== </span><span class="str">"A. Alexandrescu"</span><span class="pun">)
        </span><span class="pln">author<wbr/></span><span class="pun">.</span><span class="pln">textContent </span><span class="pun">= </span><span class="str">"Andrei Alexandrescu"</span><span class="pun">;

</span><span class="com">// write it out to "catalogue.xml"
</span><span class="kwd">auto </span><span class="pln">file </span><span class="pun">= </span><span class="typ">File</span><span class="pun">(</span><span class="str">"catalogue.xml"</span><span class="pun">, </span><span class="str">"w"</span><span class="pun">);
</span><span class="pln">file<wbr/></span><span class="pun">.</span><span class="pln">lockingTextWriter
    <wbr/></span><span class="pun">.</span><span class="pln">writerFor</span><span class="pun">!</span><span class="typ">string   </span><span class="com">// instatiates an xml writer on top of an output range
    <wbr/></span><span class="pun">.</span><span class="pln">writeDOM</span><span class="pun">(</span><span class="pln">dom</span><span class="pun">);     </span><span class="com">// write the document with all of its children</span></code></pre>
<p>   Also available is a SAX parser, which we will use to find all text nodes containing
   a specific word:
</p>
<pre class="code"><code class="lang-d"><span class="com">// don't bother about the type of a node: the library will do the right instantiations
</span><span class="kwd">static struct </span><span class="typ">MyHandler</span><span class="pun">(</span><span class="typ">NodeType</span><span class="pun">)
{
    </span><span class="typ">void </span><span class="pln">onText</span><span class="pun">(</span><span class="kwd">ref </span><span class="typ">NodeType </span><span class="pln">node</span><span class="pun">)
    {
        </span><span class="kwd">if </span><span class="pun">(</span><span class="pln">node<wbr/></span><span class="pun">.</span><span class="pln">getContent<wbr/></span><span class="pun">.</span><span class="pln">splitter<wbr/></span><span class="pun">.</span><span class="pln">find<wbr/></span><span class="pun">.</span><span class="pln">canFind</span><span class="pun">(</span><span class="str">"D"</span><span class="pun">))
            </span><span class="pln">writeln</span><span class="pun">(</span><span class="str">"Match found: "</span><span class="pun">, </span><span class="pln">node<wbr/></span><span class="pun">.</span><span class="pln">getContent</span><span class="pun">);
    }
}

</span><span class="kwd">auto </span><span class="pln">saxParser </span><span class="pun">=
     </span><span class="pln">chooseParser</span><span class="pun">!</span><span class="pln">input     </span><span class="com">// this is a shorthand for chooseLexer!Input.parse
    <wbr/></span><span class="pun">.</span><span class="pln">cursor
    <wbr/></span><span class="pun">.</span><span class="pln">saxParser</span><span class="pun">!</span><span class="typ">MyHandler</span><span class="pun">;   </span><span class="com">// only this call changed from the previous example chain

</span><span class="pln">saxParser<wbr/></span><span class="pun">.</span><span class="pln">setSource</span><span class="pun">(</span><span class="pln">input</span><span class="pun">);
</span><span class="pln">saxParser<wbr/></span><span class="pun">.</span><span class="pln">processDocument</span><span class="pun">;  </span><span class="com">// this call triggers the actual work

// With the same input of the first example, the output would be:
// Match found: The D Programming Language
// Match found: Programming in D</span></code></pre>
<p>   You may want to perform extra checks on the input, to guarantee correctness;
   this is achieved by plugging custom components in the chain.
   Let's use this feature to validate our input and write it to a file
</p>
<pre class="code"><code class="lang-d"><span class="com">// the basic cursor only detects missing xml declarations and unparseable attributes
</span><span class="kwd">auto </span><span class="pln">callback1 </span><span class="pun">= (</span><span class="typ">CursorError </span><span class="pln">err</span><span class="pun">)
{
    </span><span class="kwd">if </span><span class="pun">(</span><span class="pln">err </span><span class="pun">== </span><span class="typ">CursorError<wbr/></span><span class="pun">.</span><span class="pln">MISSING_XML_DECLARATION</span><span class="pun">)
        </span><span class="kwd">assert</span><span class="pun">(</span><span class="lit">0</span><span class="pun">, </span><span class="str">"Missing XML declaration"</span><span class="pun">);
    </span><span class="kwd">else
        assert</span><span class="pun">(</span><span class="lit">0</span><span class="pun">, </span><span class="str">"Invalid attributes syntax"</span><span class="pun">);
}

</span><span class="com">// used by checkXMLNames, a pluggable validator
</span><span class="kwd">auto </span><span class="pln">callback2 </span><span class="pun">= (</span><span class="typ">string </span><span class="pln">s</span><span class="pun">) { </span><span class="kwd">assert</span><span class="pun">(</span><span class="lit">0</span><span class="pun">, </span><span class="str">"Invalid XML element name"</span><span class="pun">); }
</span><span class="kwd">auto </span><span class="pln">callback3 </span><span class="pun">= (</span><span class="typ">string </span><span class="pln">s</span><span class="pun">) { </span><span class="kwd">assert</span><span class="pun">(</span><span class="lit">0</span><span class="pun">, </span><span class="str">"Invalid XML attribute name"</span><span class="pun">); }

</span><span class="kwd">auto </span><span class="pln">cursor </span><span class="pun">=
    <wbr/>.</span><span class="pln">chooseParser</span><span class="pun">!</span><span class="pln">input</span><span class="pun">((){ </span><span class="kwd">assert</span><span class="pun">(</span><span class="lit">0</span><span class="pun">, </span><span class="str">"Parser error"</span><span class="pun">) })    </span><span class="com">// most components take an
    <wbr/></span><span class="pun">.</span><span class="pln">cursor</span><span class="pun">(</span><span class="pln">callback1</span><span class="pun">)                                      </span><span class="com">// optional error handler
     // time to plug-in a validator
    <wbr/></span><span class="pun">.</span><span class="pln">elementNestingValidator</span><span class="pun">!(
        (){ </span><span class="kwd">assert</span><span class="pun">(</span><span class="lit">0</span><span class="pun">, </span><span class="str">"Wrong nesting of xml tags"</span><span class="pun">); }       </span><span class="com">// called if tags are not well nested
    </span><span class="pun">);

</span><span class="kwd">auto </span><span class="pln">writer </span><span class="pun">=
     </span><span class="pln">myOutputRange                                          </span><span class="com">// a writer builds on top of an output range
    <wbr/></span><span class="pun">.</span><span class="pln">writerFor</span><span class="pun">!(</span><span class="pln">cursor<wbr/></span><span class="pun">.</span><span class="typ">StringType</span><span class="pun">)
    <wbr/>.</span><span class="pln">withValidation</span><span class="pun">!</span><span class="pln">checkXMLNames</span><span class="pun">(</span><span class="pln">callback2</span><span class="pun">, </span><span class="pln">callback3</span><span class="pun">)     </span><span class="com">// we can also apply validations while writing back
    <wbr/></span><span class="pun">.</span><span class="pln">writeCursor</span><span class="pun">(</span><span class="pln">cursor</span><span class="pun">)                                    </span><span class="com">// write the entire contents of the cursor</span></code></pre>
<p>   While DOM and SAX are simple, standardized APIs, you may want to directly use
   the underlying Cursor API, which provides great control, flexibility and speed,
   at the price of a slightly lower abstraction level:
</p>
<pre class="code"><code class="lang-d"><span class="com">// A function to inspect the entire document recursively, writing the kind of nodes encountered
</span><span class="typ">void </span><span class="pln">writeRecursive</span><span class="pun">(</span><span class="pln">T</span><span class="pun">)(</span><span class="kwd">ref </span><span class="pln">T cursor</span><span class="pun">)
{
    </span><span class="com">// cycle the current node and all its siblings
    </span><span class="kwd">do
    </span><span class="pun">{
        </span><span class="pln">writeln</span><span class="pun">(</span><span class="pln">cursor<wbr/></span><span class="pun">.</span><span class="pln">getKind</span><span class="pun">);
        </span><span class="com">// if the current node has children, inspect them recursively
        </span><span class="kwd">if </span><span class="pun">(</span><span class="pln">cursor<wbr/></span><span class="pun">.</span><span class="pln">enter</span><span class="pun">)
        {
            </span><span class="pln">writeRecursive</span><span class="pun">(</span><span class="pln">cursor</span><span class="pun">);
            </span><span class="pln">cursor<wbr/></span><span class="pun">.</span><span class="pln">exit</span><span class="pun">;
        }
    }
    </span><span class="kwd">while </span><span class="pun">(</span><span class="pln">cursor<wbr/></span><span class="pun">.</span><span class="pln">next</span><span class="pun">);
}

</span><span class="kwd">auto </span><span class="pln">cursor </span><span class="pun">=
     </span><span class="pln">chooseParser</span><span class="pun">!</span><span class="pln">input
    <wbr/></span><span class="pun">.</span><span class="pln">cursor</span><span class="pun">;                </span><span class="com">// this time we stop here and use the cursor directly

</span><span class="pln">cursor<wbr/></span><span class="pun">.</span><span class="pln">setSource</span><span class="pun">(</span><span class="pln">input</span><span class="pun">);
</span><span class="pln">writeRecursive</span><span class="pun">(</span><span class="pln">cursor</span><span class="pun">);     </span><span class="com">// call our function</span></code></pre>

<p>   <h2>Library overview</h2>
</p>

<p>   <h3>The parsing chain</h3>
</p>


<p>   The xml input may come into different forms: a big string, a range of smaller
   strings, a range of characters, and so on. The first layer of the chain, the
   lexer, has the purpose of hiding the input details from the higher levels.
</p>

<p>   Then comes the parser, which does the hard job of tokenizing the input, without
   caring about the details, so that it is suitable for parsing many XML-like languages,
   like HTML.
</p>

<p>   The third component is the cursor, the heart of this library. A cursor can be seen
   as a pointer into the stream of xml nodes. It points to a single node, and provides
   methods to access the details of that node. The cursor is forward-only: it cannot
   get back to a previous node. But it can advance in smart ways: for example, it
   knows how to skip all children of a node, if the user doesn't care about them.
   The cursor API is the "intermediate language" of the library: many transformations
   and validations happen at this stage, whose output is then used by all higher level
   APIs (e.g. DOM and SAX).
</p>

<p>   Each component in this chain can be substituted with a custom one, providing high
   flexibility. The entire library is built as a collection of small components with
   standardized APIs that can easily be composed together as needed.
</p>

<p>   To allow fast and memory-light parsing, the parsing chain does not provide any
   guarantee about the lifetime of its output: in general, every string returned
   by any component must be considered invalidated by the advancement to another
   component, unless stated otherwise. This allows lexers to reuse their buffers
   for each input token, and every component that needs to store some data for later
   use must copy it.
</p>

<p>   <h3>The cursor wrappers</h3>
</p>


<p>   Transformations and validations of the xml nodes happen at the cursor level,
   via a number of optional, pluggable and configurable components. These are constructed
   on top of a cursor, and expose the cursor API themselves, thus being completely
   transparent to higher levels that simply expect a cursor.
</p>

<p>   These components work by forwarding every API call to the underlying cursor,
   applying custom operations, before and after, when needed. This is another area
   in which the user is free to provide his own implementations with custom functionality,
   but the library already provides a set of useful operations, ranging from
   copying/interning strings for later use to checking the well-formedness of some
   parts of the document.
</p>

<p>   <h3>The DOM</h3>
</p>


<p>   The DOM, as described in the official specification, is purely object-oriented,
   based on interfaces and runtime polymorphism. This library doesn't want to
   change this approach, and provides a the set of interfaces specified by the
   DOM Level 3 specification, so that the other libraries can provide custom implementations
   that can still interact with this library (e.g. use the DOMBuilder provided here).
</p>

<p>   But D also provides powerful template programming facilities, and this libraries
   uses them extensively; the DOMBuilder is templated on the DOM Implementation:
   choosing to instantiate it with the generic interface will give a builder that can
   construct any possible implementation, while instantiating it with a concrete
   class will give a specialized builder that can work in <code class="lang-d"><span class="kwd">@safe</span></code>, <code class="lang-d"><span class="kwd">@nogc</span></code>, <code class="lang-d"><span class="kwd">pure</span></code>,
   <code class="lang-d"><span class="kwd">nothrow</span></code> contexts (depending on the characterstics of the concrete implementation).
   The default DOM implementation provided by this library is thought for @nogc usage,
   with the ability to specify a custom allocator.
</p>

<p>   <h3>The writer API</h3>
</p>


<p>   The writer API allows to output xml data to any OutputRange. Despite being simpler
   than the input API, it is still very flexible and customizable. The user can
   apply custom validations (built with the cursor API, so the same components
   used for validating on input can be reused) and define custom pretty-printers
   to write nicer or shorter xml.
</p>

<p>   The library also provides some custom higher level wrappers to directly write
   the contents of cursors or entire DOM trees.
</p>
</section>

			<section></section>
			<section>
				<h2>Authors</h2>
<p>Lodovico Giaretta
</p>

			</section>
			<section>
				<h2>Copyright</h2>
<p>Copyright Lodovico Giaretta 2016 --
</p>

			</section>
			<section>
				<h2>License</h2>
<p><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
</p>

			</section>
		</div>
	</body>
</html>